Advance Interview Concepts
NPM:- npm is a package manager. npm is a repository where all the libraries, frameworks, and tools are available.

Types of Dependency:- There are two types of dependency.
1) Dev Dependency- Generally required in the developing phase
2) Normal Dependency- Used in the production phase

‚óΩDifference between caret and tilde 
1) Caret (^): The caret is used to specify a range of compatible versions with some flexibility.
	When used with a major version number, it allows for backward-compatible updates.
2) Tilde (~): The tilde is used to specify a range of versions with a more restrictive approach.
	It allows only for updates within the same major version and includes patch-level updates.

‚óΩPackage.json:- It is a configuration for npm. It keeps attracting, of what version is installed in our app.

‚óΩPackage-lock.json:- It locks the version and keeps the exact version record.

‚óΩNode-Modules:- It contains the code which we fetch from the NPM or we can say it is like a database where our all code exists.

‚óΩParcel:- Parcel is a web application bundler that simplifies the process of building and bundling web applications.
Parcel simplifies the development workflow by providing a fast, easy-to-use, and zero-configuration bundling solution.
It reduces the initial setup time, improves development productivity with features like HMR, and automatically optimizes the performance of the bundled output.

‚óΩSuperpower of Parcel:- 
HMR - Hot Module Replacement
File watching algorithm => written in C++
Caching => Faster Builds
Image Optimization
Minification
Bundling
Compressing
Consistent Hashing
Code Splitting
Differential Bundling - Support older browsers
Diagnostic
Error Handling
HTTPS
Tree Shaking

‚óΩTree Shaking:- Tree shaking is a technique used in JavaScript module bundlers,
such as Webpack or Parcel, to eliminate unused code from the final bundled output.
It helps optimize the bundle size by removing dead or unreachable code.
================================================================================================================================================================================
Event Loop:

The event loop is a fundamental concept in JavaScript that allows it to handle asynchronous operations
and maintain a responsive user interface in a single-threaded environment.
It plays a crucial role in the execution of JavaScript code,
especially when dealing with tasks like network requests, user interactions, timers, and more.

1. Single-Threaded Nature of JavaScript:
JavaScript is a single-threaded language, meaning it has only one main execution thread to process code.
This single thread executes code sequentially, line by line, and can handle one task at a time.

2. Blocking vs. Non-Blocking:
In a single-threaded environment, if a task takes a long time to complete (e.g., fetching data from a server), it can block the entire program, making it unresponsive.
JavaScript uses non-blocking operations to avoid this issue. It starts an operation and continues executing other tasks while waiting for the non-blocking operation to complete.

3. Event Loop Overview:
The event loop is a mechanism that allows JavaScript to manage and execute asynchronous operations efficiently.
It consists of three main components: the call stack, the callback queue (task queue), and the microtask queue.

4. Call Stack:
The call stack is a data structure that keeps track of the execution context of functions.
When a function is called, its context is pushed onto the stack. When it completes, it's popped off the stack.

5. Callback Queue (Task Queue):
The callback queue, often referred to as the task queue, stores tasks or functions (callbacks) that are ready to be executed.
These tasks typically include I/O operations, timers (e.g., setTimeout), and event handlers (e.g., click events).

6. Microtask Queue:
The microtask queue is a special queue that stores tasks with higher priority than those in the callback queue.
Promises and certain APIs (e.g., MutationObserver) generate microtasks.
When promises are resolved or rejected, their associated callbacks are added to the microtask queue.

Event Loop Flow:
The event loop continuously checks the call stack to see if it's empty. If the call stack is empty.
It first checks the microtask queue. If there are microtasks, they are executed one by one, in order of insertion, until the microtask queue is empty.
After the microtask queue is empty, the event loop checks the callback queue and executes tasks (callbacks) from there one by one, also in the order they were added.
This cycle continues, with the event loop checking and executing microtasks and tasks,
ensuring that asynchronous operations are processed efficiently without blocking the main program.

In simple terms, the event loop allows JavaScript to handle multiple asynchronous tasks, ensuring that they are executed in a non-blocking manner and in a specific order. It helps maintain the responsiveness of web applications and ensures predictable behavior in an otherwise single-threaded environment.
================================================================================================================================================================================

Closures- 
A closure is the combination of a function and the lexical environment within which that function was declared.
OR
When inner function can have access to the outer function variables and parameter.

The return statement does not execute the inner function - function is only executed only when followed by ()parathesis, but rather than returns the entire
body of the function.

Uses/advantages of closures:
-event handlers
-callback functions
-Encapsulation: can store data in separate store
-Object data privacy
-Module Design Pattern
-Currying
-Functions like once
-memoize
-setTimeouts
-Iterators
-maintaining state in async world

Disadvantages of closures:
1. Creating function inside a function leads to duplicate in memory and cause slowing down the application means use only when required privacy.
2. As long as the clousers are active, the memory can't be garbage collected means if we are using clousers in ten places then untill all the 10 process complete 
it hold the memory and can overcome to set closure to Null.

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  innerFunction()
}
outerFunction(5)// 15

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  return innerFunction
}
outerFunction(5) //output : 
 ()=>{
    let sum = a+b;
    console.log(sum)
  }

const outerFunction =(a)=>{
  let b=10;
  const innerFunction =()=>{
    let sum = a+b;
    console.log(sum)
  }
  return innerFunction
}
let inner = outerFunction(5)
console.log(inner)
inner() //15
================================================================================================================================================================================
Prototype: 
Prototype allow to easily define methods to all the instances of object. It stored in the memory once but every object instances can access it.

1. Javascript is a prototype based language, so, whenever we are creating a function using javascript, javascript engine adds a prototype property inside a function,
Prototype property is basically an object (also known as Prototype object), where we can attach methods and properties in a prototype object, which enables all the
other objects to inherit these methods and properties.
2. We are creating prototype in constructor function. All the intances of objects can able to access properties and methods from constuctor function.
3. The prototype is an object that is associated with every functions and objects by default in JavaScript, where function's prototype property is accessible and 
modifiable and object's prototype property (aka attribute) is not visible.
4. object's prototype property is invisible. Use Object.getPrototypeOf(obj) method instead of __proto__ to access prototype object.
5. prototype is useful in keeping only one copy of functions for all the objects (instances).
6. An Object has a prototype. A prototype is also an object. Hence Even it may have its own prototype object. This is referred to as prototype chain.

<A>Several Types:
1. Object.prototype- It is a prototype OBJECT of object(cunstruction function where it will inherit all properties of Object.protorype). 
Prototype Object of Object.prototype is NULL.
2. Array.prototype-Prototype Object of Array.prototype is Object.prototype and Prototype Object of Object.prototype is NULL.
3. Function.prototype
4. Example-
var person = function(name){
   this.name = name;
}
person.prototype.age = 21;
var piya = new person("Piya");
var priya = new person("Priya");
console.log(piya.age) //21
console.log(priya.age) //21

<B>Purpose/Use of prototype:
1) to find properties and methods of an object 
2) to implement inheritance in JavaScript

<C>Difference between Prototype and __proto__:
1. In reality, the only true difference between prototype and __proto__ is that the former is a property of a class constructor, 
   while the latter is a property of a class instance.
2. Instances have __proto__, classes have prototype.
3. Instances of a constructor function use __proto__ to access the prototype property of its constructor function.
4. __proto__ is invisible property of an object. It returns prototype object of a function to which it links to. 
5. __proto__ is Deprecated. 
6. Example:
function Person(name){
    this.name = name
 }; 
var eve = new Person("Eve"); 
eve.__proto__ == Person.prototype //true
eve.prototype  //undefined
7. Example:
function Person() {
    this.name = 'John'
}
// adding property 
Person.prototype.name = 'Peter';
Person.prototype.age = 23
const person1 = new Person();
console.log(person1.name); // John
console.log(person1.age); // 23

================================================================================================================================================================================
CSS Positions:

1. Static: HTML elements are positioned static by default. Static positioned elements are not affected by the top, bottom, left, and right properties. 
   Object can't move. it is always positioned according to the normal flow of the page.
2. Relative: Object can move. It is positioned relative to its normal position. If want gap from its actual placed position then use it. It work with left,
   right, top, bottom properties.
3. Fixed: Not allow to scroll up or down. is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. 
   The top, right, bottom, and left properties are used to position the element. The element is positioned relative to the browser window
4. Absolute: it is work with relative i.e, w.r.t parent. It is positioned relative to the nearest positioned ancestor (instead of positioned relative to the 
   viewport, like fixed). if an absolute positioned element has no positioned ancestors, it uses the document body, and moves along with page scrolling.
5. Sticky: An element with position: sticky; is positioned based on the user's scroll position. Internet Explorer does not support sticky positioning. 
   You must also specify at least one of top, right, bottom or left for sticky positioning to work. Use for to create menu.

================================================================================================================================================================================
Time based Event:

SetTimeout: 
1. allows us to run a FUNCTION ONCE, after the interval of time
2. setTimeout() executes the passed function after given time. The id_value returned by setTimeout() function is stored in a variable and 
   it‚Äôs passed into the clearTimeout() function to clear the timer. 
3. Syntax- let timerId = setTimeout(function, milliseconds, [arg1], [arg2], ...)
4. Don't make a mistake by adding brackets () after the function otherwise gives undefined and nothing will scheduled.
5. Example-
let timerId = function sayHi(phrase, who) {
  console.log( phrase + who );
}
setTimeout(sayHi, 1000, "Hello", "John"); 

SetInterval:
1. allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.
2. setInterval() executes the passed function for the given time interval. The number id value returned by setInterval() function is stored 
   in a variable and it‚Äôs passed into the clearInterval() function to clear the interval.
3. Syntax-
4. Example
let timerId = function sayHi(phrase, who) {
  console.log( phrase + who );
}
setInterval(sayHi, 1000, "Hello", "John");

ClearTimeout:
1. This method is used to cancel a setTimeout().  Inside the method you have to reference the timeoutID.
clearTimeout(timerId)

ClearInterval:
1. This method is used to cancel a setInterval().  Inside the method you have to reference the intervalID.
clearInterval(timerId)
================================================================================================================================================================================
                                          
Debouncing and Throttling in JavaScript: using in search box, scrolling or resize the widow size

1. It Creates impact on performance of your website, but also prevent unnecessary API calls and load on the server.
2. Throttling and debouncing are techniques used to control the frequency of executing a function. It is useful when dealing with user interactions and optimizing performance. 
3. The main difference between throttling and debouncing is that throttling executes the function at a regular interval, while debouncing executes the function only 
   after some cooling period.
4. Example: If you're scrolling, throttle will slowly call your function while you scroll (every X milliseconds). Debounce will wait until after you're done scrolling 
   to call your function.

examples : on button click, mouse move, search bar, window scrolling and window resize allow the user to decide when to execute.

Throttling-
Throttling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval.
                                                                        or
Throttling limits the execution of a function to a specified interval, ensuring that it is not called more frequently than the defined delay.

import React, { useState, useEffect } from 'react';
function ThrottleExample() {
  const [count, setCount] = useState(0);

  const throttle = (func, delay) => {
    let timeout;  //  

    return function () {
      if (!timeout) {
        func.apply(this, arguments);    // this represents - capture the current context    //argumenst represents - capture the arguments passed to the throttle
        timeout = setTimeout(() => {
        timeout = null;
      }, delay);
      }
    };                                   
  };                                    

  const handleClickThrottle = throttle(() => {
    setCount(count + 1);
  }, 1000);

  return (
    <div>
      <p>Throttle Example: {count}</p>
      <button onClick={handleClickThrottle}>Increment</button>
    </div>
  );
}

export default ThrottleExample;
In this example, the throttle function ensures that the handleClickThrottle function can only be called once every 1000 milliseconds (1 second), preventing rapid clicking.
================================================================================================================================================================================

Debouncing- 
No matter how many times the user fires the event, the attached function will be executed only after the specified time once the user stops firing the event.
The Debounce technique allow us to ‚Äúgroup‚Äù multiple sequential calls in a single one.
                                                        or
Debouncing postpones the execution of a function until a specified amount of time has passed since the last invocation.
It is typically used in scenarios where the function should only be triggered once a certain event has stopped occurring.

import React, { useState, useEffect } from 'react';

function DebounceExample() {
  const [input, setInput] = useState('');
  const [output, setOutput] = useState('');

  const debounce = (func, delay) => {
    let timer;

    return function () {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(this, arguments);
      }, delay);
    };
  };

  const handleChangeDebounce = (event) => {
    const inputValue = event.target.value;

    const updateOutput = debounce(() => {
      setOutput(inputValue);
    }, 1000);

    updateOutput();
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Type something..."
        onChange={handleChangeDebounce}
      />
      <p>Debounced Output: {output}</p>
    </div>
  );
}

export default DebounceExample;

In this example, the handleChangeDebounce function is debounced, so it only updates the output state after a 1000ms (1 second) pause in typing.
This is particularly useful for search bars and filtering in real-time.
================================================================================================================================================================================

CALL, APPLY and BIND method: These methods allow us to write a function once and invoke it in a different context. They all attach this into a function (or object) 
and the difference is in the function invocation. Call and apply are pretty interchangeable. Just decide whether it‚Äôs easier to send in an array or a comma separated 
list of arguments. I always remember which one is which by remembering that Call is for comma (separated list) and Apply is for Array. Bind is a bit different. 
It returns a new function. Call and Apply execute the current function immediately. The main concept behind all this methods is Function burrowing.

CALL:
1. It is predefined javascript method.
2. call is used to invoke a function with a specified this value and individual arguments passed one by one.
3. It's useful when you know the exact number of arguments the function expects and you can pass them individually. 

APPLY:
1. Apply is also used to invoke a function with a specified this value, but it takes arguments as an array. 
2. It's helpful when you want to pass an array of arguments to a function or when the number of arguments may vary. 

BIND:
1. We can bind an object to a common function, so that the function gives different results when its need.
2. It takes an object as an first argument and creates a new function.
                                                or
1. Bind returns a new function with a bound this value but does not immediately invoke the function. 
2. It's commonly used when you want to create a new function with a fixed this value to be called later. 

summary :
1. call and apply both invoke a function with a specified this value, but call takes individual arguments, while apply takes an array of arguments. 
2. bind returns a new function with a fixed this value, which can be called later with any number of arguments.

Example1:
const employee = {
  fName: "Manoj",
  Lname:"Odela"
}
const Details = function(a, b){
  console.log("Hi "+this.fName+" "+this.Lname+" "+ a +" "+ b)
}

Details.call(employee, "Hello", "How are you"); //Hi Manoj Odela Hello How are you
Details.apply(employee, ["Hello", "How are you"]); //Hi Manoj Odela Hello How are you
let result = Details.bind(employee);
result("good morning", "!"); //Hi Manoj Odela good morning !

Example2:
const obj = {name:"Priya"}
let greeting = function(a,b){
  return a+" "+this.name+" "+b;
}
console.log(greeting.call(obj, "Hello", "How are you?"));
console.log(greeting.apply(obj, ["Hello", "How are you?"]));
let test=greeting.bind(obj);
console.log(test("Hello", "How are you?"))

================================================================================================================================================================================

Hoisting:
1. Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope during the compilation phase.
2. This means that you can use variables and functions before they are declared in your code.
3. However, only the declarations are hoisted, not the initializations or assignments.
4. Hoisting is the process of putting all declarations, such as variables and functions, into memory during the compile phase.

-------------------------------------------------------------------
console.log(a); // undefined
console.log(b); // ReferenceError
console.log(c); // ReferenceError

var a = 10;
let b = 20;
const c = 30;

1. Variables declared with var will be hoisted and initialized with undefined.
2. Variables declared with let and const, are hoisted, but not initialized with undefined.
3. They can be accessed only after initialization, otherwise we receive a ReferenceError.
4. This is because of the Temporal Dead Zone, a time window where the variable exists but it still uninitialized. 

----------------------------------------------------------------------
greet1();
greet2();
greet3();
greet4();

// function declaration is fully hoisted
function greet1() {
  console.log("HELLO");
}

// TypeError: greet1 is not a function
var greet2 = function () {
  console.log("HELLO");
};

// ReferenceError: Cannot access 'greet3' before initialization
let greet3 =  () =>  {
  console.log("HELLO");
};

//Uncaught TypeError: greeting1 is not a function because its treeting like a variable not a function, so rather then storing a function body it's storing undefined by default.
const greet4 = function () {
  console.log("HELLO");
};

1. Traditional function declarations will be fully hoisted thus making function accessible throughout our code.
2. But with function expressions and arrow functions, we are unable to call a function before it has been declared. 
3. In order to solve these errors Either change the function expression/arrow functions to traditional function declarations or call the function after the declarations.

================================================================================================================================================================================
Window and This:

Window:
1. Javascript engine create global context execution and allocate some memory space. It is a big object with lot of methods and functions which is created in global space 
by JS engine.
2. Window is the main JavaScript object root, aka the global object in a browser, and it can also be treated as the root of the document object model. You can access it as window.
3. window.document or just document is the main object of the potentially visible (or better yet: rendered) document object model/DOM.
4. window is the global object, you can reference any properties of it with just the property name - so you do not have to write down window. - it will be figured out by the runtime.
5. window.document.getElementById("header") is the same as document.getElementById("header").

This:
1. At global level THIS points to the window. 
2. With Window object THIS variable is created by default.
3. This === window //true

Example:
var a=10;
function b(){
 var x=10;
}
console.log(window.a); //10
console.log(a); //10
console.log(this.a); //10
================================================================================================================================================================================

Even Propogation an STOP Propogation: Bydefault event capturing happen first and then even bubbling happen.

Event Bubbling:
1. When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors. With bubbling, the event is 
   first captured and handled by the innermost element and then propagated to outer elements.
2. Bydefault event bubbling execute. To run event bubbling required to mention 3rd argument as FALSE or nothing.
3. "child clicked"
"parent clicked"
"grandparent clicked"
4. Drawback: Bubbling not occur at blur, focus, resizing of window etc.

Event Capturing or Event Trickling:
1. With capturing, the event is first captured by the outermost element and propagated to the inner elements.
2. To run event capturing required to mention 3rd argument as TRUE.
3. "grandparent clicked"
"parent clicked"
"child clicked"

Example:
html-
<div id="grandparent">
  <div id="parent">
    <div id="child">
      </div>
</div>
</div>

css-
div{
  min-width: 10px;
  min-height: 10px;
  border: 1px solid red;
  padding: 30px;
}

js-
for bubbling:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, false);
or
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")});
document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")}, false);
or
document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")});
document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")}, false);
or
document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")})

------------------------------

for capturing:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, true);
document.querySelector("#parent").addEventListener("click",()=> {console.log("parent clicked")},true);
document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")},true); 

stopPropogation:
document.querySelector("#grandparent").addEventListener("click",()=> {console.log("grandparent clicked")}, false);

document.querySelector("#parent").addEventListener("click",(e)=> {console.log("parent clicked"); e.stopPropogation()},false);

document.querySelector("#child").addEventListener("click",()=> {console.log("child clicked")},false); 

================================================================================================================================================================================
Event Delegation:

1. Event delegation makes use of one of the Event Propagation techniques called Event Bubbling
2. if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them ‚Äì we put a single handler on their common ancestor.
3. In the handler we get event.target to see where the event actually happened and handle it.
4. Less memory usage, better performance.
5. Less time required to set up event handlers on the page.
6. Event delegation is a pattern to handle events efficiently in JavaScript. The main idea is to reduce the number of event handlers on a webpage and thus 
   improving the performance of the website.
7. When there are multiple DOM elements present, instead of adding event handlers on each one of them, you can just add one event handler 
   (on the parent/common ancestor element) which can do the exact same work which all those multiple event handlers were supposed to do.

Example:

html-
Counter: <input type="button" value="1" data-counter>
One more counter: <input type="button" value="2" data-counter>
<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { 
      event.target.value++;
      console.log(event.target.value)
    }
  });
</script>
================================================================================================================================================================================
Polyfill:

1. With the help of polyfill can write own implementation of BIND function.
2. Polyfills is a way to use modern features (usually JS) on browsers where it is currently unsupported.  We do this by mimicking the functionality using supported methods 
along with our own logic.
3. A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it.

Polyfill: Sometimes array push, pop or filter methods and some window's functions like window.localstorage and window.sessionstorage these functions are not supported
by browser, so in this case we can provide our own fallback support or own code that it replace the native functions

Example for bind:
With Bind-
let name ={
  first: "Priya",
  last: "Bagde"
}
let printName = function(){
  console.log(this.first+this.last)
}
let printNameFinal= printName.bind(name)
printNameFinal()

Without Bind-
let name ={ first: "Priya", last: "Bagde"}
let printName = function(town, state){ console.log(this.first+" "+this.last+" "+town+" "+state)}
Function.prototype.mybind= function(...args){ //printName arguments
  let obj = this; //printName
  params = args.slice(1)
  return function(...args2){ //printNameFinal arguments
   obj.apply(args[0], [...params, ...args2])
  }
}
let printNameFinal= printName.mybind(name, "chhindwara")
printNameFinal("MadyaPradesh")
================================================================================================================================================================================
Promises:-

üëâWhy do you need a promise?
‚úåüèºPromises are used to handle asynchronous operations. They provide an alternative approach for callbacks by reducing the callback hell and writing the cleaner code.

üëâWhat are the three states of promise ?
‚úåüèºPromises have three states: 
	pending: initial state, neither fulfilled nor rejected.
	fulfilled: meaning that the operation completed successfully.
	rejected: meaning that the operation failed. In this case an error value will be thrown.

üëâWhat is promise chaining ?
‚úåüèºThe process of executing a sequence of asynchronous tasks one after another using promises is known as Promise chaining.

üëâWhat is promise.all ?
‚úåüèºPromise.all is a promise that takes an array of promises as an input (an iterable), and it gets resolved when all the promises get resolved or any one of them gets rejected. For example, the syntax of promise.all method is below,
Promise.all([Promise1, Promise2, Promise3])
.then(result) => { console.log(result) })
.catch(error => console.log(`Error in promises ${error}`))

üëâWhat are the pros and cons of promises over callbacks ?
‚úåüèºPros:
It avoids callback hell which is unreadable
Easy to write sequential asynchronous code with .then()
Easy to write parallel asynchronous code with Promise.all()
Solves some of the common problems of callbacks(call the callback too late, too early, many times and swallow errors/exceptions)
Cons:
It makes little complex code
You need to load a polyfill if ES6 is not supported

üëâHow to cancel a fetch request ?
‚úåüèºOne shortcoming of native promises is no direct way to cancel a fetch request. But the new AbortController from js specification allows you to use a signal to abort one or multiple fetch calls. 
================================================================================================================================================================================
üëâWhat are default parameters?
‚úåüèºIn E5, we need to depend on logical OR operators to handle default values of function parameters.
Whereas in ES6, Default parameters allow you to assign default values to function parameters.
If a parameter is not provided when the function is called, it will use the default value.

Let's compare the behavior with an examples,
//ES5
var calculateArea = function(height, width) {
   height =  height || 50;
   width = width || 60;
   return width * height;
}
console.log(calculateArea()); //300
//ES6
var calculateArea = function(height = 50, width = 60) {
   return width * height;
}
console.log(calculateArea()); //300

‚úåüèºAfter default parameters you should not have parameters without default value-
function printValue(a=1, b) {
    console.log("a = " + a + " and b = " + b);
}
printValue();    // Logs: a = 1 and b = undefined
printValue(7);    // Logs: a = 7 and b = undefined
printValue(7, 3);    // Logs: a = 7 and b = 3

‚úåüèºDefault values for parameters and calling it without arguments-
function add(a=10, b=20)
{
	return a+b;
}
console.log(" Sum is : " + add());   // No argument //30
console.log(" Sum is : " + add(1));   // with one argument //21
console.log(" Sum is : " + add(5,6));   // with both argument  //11

‚úåüèºJavaScript Default Parameters with null or empty Argument-
function test(a = 1)
{
    console.log(typeof a);
    console.log("Value of a: " + a);
}
test();    // number, Value of a: 1
test(undefined);    // number, Value of a: 1
test('');    // string, Value of a: 
test(null);    // object, Value of a: null

‚úåüèºDefault Parameters are evaluated at Call time-
function append(value, array = []) {
    array.push(value)
    return array
}
append(1)  // [1]
append(2)  // [2], not [1, 2]
================================================================================================================================================================================
JWT Token:
1. JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.
2. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a public/private key pair using RSA.
================================================================================================================================================================================
Rest operator:
1. The rest operator is used in function parameters to collect multiple arguments into a single array.
2. It's especially useful when you want to work with a variable number of arguments.

Syntax: It is denoted by three dots (...) followed by a parameter name that will hold the rest of the arguments.

// Rest Parameter in Array : 
function addSum(a,b,c, ...rest){ // ...rest indicating combination of those arguments which are left(rest).
  console.log(...rest) //6,7
  console.log(rest) //[6,7]
  console.log(arguments) //ES5 //{"0":2, "1":3, "2":4, "3":6, "4":7}
  return a+b+c+rest[0]+rest[1];
}
console.log(addSum(2,3,4,6,7)) //22

// Rest Spread in object: 
var student ={
  name: "priya",
  age : 100,
  hobbies : ["cooking", "dancing"]
}

//const age = student.age; //earlier we like this
//console.log(age) //10

//const {age, ...rest} = student; //using destructuring
//console.log(age, rest) //100 {"name": "priya", "hobbies":["cooking", "dancing"]}

const {...rest} = student;
console.log(rest) //{"name": "priya", "age": 100, "hobbies":["cooking", "dancing"]}
======================================================================================================================================================================
Spread Operator: 
1. The spread operator allows you to expand an iterable (like an array or a string) into individual elements.
2. It's used for various tasks, such as creating shallow copies of arrays, merging arrays, and passing multiple arguments to functions.
Syntax: It is denoted by three dots (...) followed by the iterable you want to spread.

//Spread Operator  in Array:
function getNames(name1, name2, name3){
  console.log(name1,name2, name3);
}
var names =["priya", "riya", "supriya"]
getNames(names[0], names[1], names[2]); //"priya" "riya" "supriya"
getNames(...names) //spread operator here used to spread the individual arguments //best approach because here we are passing all the arguments but we can use some of the arguments inside function without an error. Other approaches will gives an error to pass those arguments which are used in function.
getNames(names)

//spread operator in object: (Change the value of age)
var student ={
  name: "priya",
  age : 100,
  hobbies : ["cooking", "dancing"]
}

var newStudent ={
  ...student, //coping one object to another object
  age : 101
}
console.log(newStudent)
====================================================================================================================================================================

Default Parameter:
1.Default parameters allow you to assign default values to function parameters. 
2. If a parameter is not provided when the function is called, it will use the default value.

Syntax: Default parameters are assigned within the function's parameter list using the assignment operator (=).

function greet(name = "Guest") {
  return `Hello, ${name}!`;
}
const greeting = greet(); // "Hello, Guest!"

====================================================================================================================================================================
In summary:

Spread operator spreads elements of an iterable.
Rest operator collects multiple function arguments into an array.
Default parameter assigns a default value to a function parameter if no value is provided when calling the function.

====================================================================================================================================================================
What is the Temporal Dead Zone 

The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable with the let and const keywords, but not with var. In ECMAScript 6, accessing a let or const variable before its declaration (within its scope) causes a ReferenceError. The time span when that happens, between the creation of a variable‚Äôs binding and its declaration, is called the temporal dead zone. 

Let's see this behavior with an example, 

function somemethod() { 
  console.log(counter1); // undefined 
  console.log(counter2); // ReferenceError 
  var counter1 = 1; 
  let counter2 = 2; 
} 
====================================================================================================================================================================

What is an IIFE (Immediately Invoked Function Expression) 
IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined. The signature of it would be as below, 

(function () { 
  // logic here 
})(); 

The primary reason to use an IIFE is to obtain data privacy because any variables declared within the IIFE cannot be accessed by the outside world.
i.e, If you try to access variables from the IIFE then it throws an error as below, 

(function () { 
  var message = "IIFE"; 
  console.log(message); 
})(); 
console.log(message); //Error: message is not defined 

====================================================================================================================================================================
What is the purpose of the array slice method 

1. The slice() method returns the selected elements in an array as a new array object.
2. It selects the elements starting at the given start argument, and ends at the given optional end argument without including the last element.
3. If you omit the second argument then it selects till the end. 
4. Slice method won't mutate the original array but it returns the subset as a new array.

Some of the examples of this method are, 

let arrayIntegers = [1, 2, 3, 4, 5]; 
let arrayIntegers1 = arrayIntegers.slice(0, 2); // returns [1,2] 
let arrayIntegers2 = arrayIntegers.slice(2, 3); // returns [3] 
let arrayIntegers3 = arrayIntegers.slice(4); //returns [5] 
 
====================================================================================================================================================================

What is the purpose of the array splice method 
1. The splice() method is used either adds/removes items to/from an array, and then returns the removed item.
2. The first argument specifies the array position for insertion or deletion whereas the optional second argument indicates the number of elements to be deleted.
3. Then from the Third argument is added to the array. 
4. Splice method modifies the original array and returns the deleted array. 

Some of the examples of this method are, 

let arrayIntegersOriginal1 = [1, 2, 3, 4, 5]; 
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5]; 
let arrayIntegersOriginal3 = [1, 2, 3, 4, 5]; 
 
let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // returns [1, 2]; original array: [3, 4, 5] 
let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3] 
let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5] 


What is the difference between slice and splice

	Slice							Splice
Doesn't modify the original array(immutable)	Modifies the original array(mutable)
Returns the subset of original array		Returns the deleted elements as array
Used to pick the elements from array		Used to insert or delete elements to/from array

What is JSON and its common operations
JSON is a text-based data format following JavaScript object syntax,
It is useful when you want to transmit data across a network and
it is basically just a text file with an extension of .json, and a MIME type of application/json

Parsing: Converting a string to a native object
JSON.parse(text);

Stringification: converting a native object to a string so it can be transmitted across the network
JSON.stringify(object);


